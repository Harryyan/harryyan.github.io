<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Swift函数派发机制</title>
    <url>/2021/08/27/Swift%E5%87%BD%E6%95%B0%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="一个令人困惑的小问题"><a href="#一个令人困惑的小问题" class="headerlink" title="一个令人困惑的小问题"></a>一个令人困惑的小问题</h1><p>大家请看下面这段代码(<em>摘自objc.io twitter的swift quiz</em>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protocol Drawing &#123;</span><br><span class="line">  func render()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Drawing &#123;</span><br><span class="line">  func circle() &#123; p rint(&quot;protocol&quot;)&#125;</span><br><span class="line">  func render() &#123; circle()&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SVG: Drawing &#123;</span><br><span class="line">  func circle()&#123; print(&quot;class&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SVG().render()</span><br><span class="line"></span><br><span class="line">// what&#x27;s the output?</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>请给出你的答案😄</p>
<span id="more"></span>

<p>根据当时的统计，43%选择了protocol, 57%选择了class。但真理往往掌握在少数人手中，正确答案是protocol。objc给出的解释是: <strong>circle函数声明在protocol的extension里面，所以不是动态派发，并且类没有实现render函数，所以输出为protocol.</strong> 更为准确的说法应该是: <strong>extension中声明的函数是静态派发，编译的时候就已经确定了调用地址，类无法重写实现。</strong></p>
<h1 id="派发机制"><a href="#派发机制" class="headerlink" title="派发机制"></a>派发机制</h1><p>在更深入研究Swift函数派发机制之前，我们有必要了解下函数派发的基本知识。函数派发就是CPU在内存中找到该函数地址并调用的过程。函数派发有三种类型: <strong>静态派发，函数表派发和消息派发。</strong>当我们在选择时，需要平衡程序的执行效率和动态性，选择最适合当下情景的派发方式。</p>
<h2 id="直接派发"><a href="#直接派发" class="headerlink" title="直接派发"></a>直接派发</h2><p>直接派发是三种派发方式中最快的。CPU直接按照函数地址调用，使用最少的指令集，办最快的事情。当编译器对程序进行优化的时候，也常常将函数内联，使之成为直接派发方式，优化执行速度。我们熟知的C++默认使用直接派发方式，在Swift中给函数加上<strong>final</strong>关键字，该函数也会变成直接派发的方式。当然，有利就有弊，直接派发最大的弊病就是没有动态性，不支持继承。</p>
<h2 id="函数表派发"><a href="#函数表派发" class="headerlink" title="函数表派发"></a>函数表派发</h2><p>这种方式是编译型语言最常见的派发方式，他既保证了动态性也兼顾了执行效率。函数所在的类会维护一个”函数表”，也就是我们熟知的<strong>虚函数表</strong>。该函数表存取了每个函数实现的指针。每个类的vtable在编译时就会被构建，所以与直接派发相比只多出了两个读取的工作: <strong>读取该类的vtable</strong>和<strong>该函数的指针</strong>。理论上说，函数表派发也是一种高效的方式。不过和直接派发相比，编译器对某些含有副作用的函数却无法优化，也是导致函数表派发变慢的原因之一。而且Swift类扩展里面的方法无法动态加入该类的函数表中，只能使用静态派发的方式，这也是函数表派发的缺陷之一。</p>
<p>我们来看如下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Vehiche &#123;</span><br><span class="line">    func run() &#123;&#125;</span><br><span class="line">    func brake() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car: Vehiche &#123;</span><br><span class="line">    override func brake() &#123;&#125;</span><br><span class="line">    func speedUp() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当前情景下，编译器会创建两个函数表: 一个属于<strong>Vehiche</strong>类，另一个属于<strong>Car</strong>类，内存布局如下:</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1559693318/blogImages/Swift_Dispatch/Screen_Shot_2019-06-05_at_12.06.52_PM_n3inuw.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let car = Car()</span><br><span class="line">car.brake()</span><br></pre></td></tr></table></figure>

<p>当调用函数<strong>brake</strong>时，过程如下:</p>
<ol>
<li>读取该对象(0XB00)的vtable.</li>
<li>读取<strong>brake函数指针</strong>0x222.</li>
<li>跳转到地址<strong>0X222</strong>，读取函数实现.</li>
</ol>
<h2 id="消息派发"><a href="#消息派发" class="headerlink" title="消息派发"></a>消息派发</h2><p>这种派发方式是三种里面最动态的一种方式。由于Swfit使用的依旧是Objc的运行时系统，所以这里的消息派发其实也就是Objc的<strong>Message Passing</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id returnValue = [someObject messageName:parameter];</span><br></pre></td></tr></table></figure>

<p><strong>someObject</strong>就是接收者，<strong>messageName</strong>就是选择器，选择器和参数一起被称为 “<strong>消息</strong>“。<br>当编译时，编译器会将该消息转换成一条标准的C语言调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id returnValue = objc_msgSend(someObject, @selector(messageName:), parameter);</span><br></pre></td></tr></table></figure>

<p>objc_msgSend函数回一句接收者和选择器的类型来调用适当的方法，它会去接收者所属类中搜索其方法列表，如果能找到，则跳转到对应实现；若找不到，则沿着继承体系继续向上查找，若能找到，则跳转；如果最终还是找不到，那就执行边界情况的操作，例如 <strong>Message forwarding</strong>。</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1559694848/blogImages/Swift_Dispatch/Screen_Shot_2019-06-05_at_8.33.29_AM_nwr7rv.png"></p>
<p>这样做的好处在哪里呢？这种运作方式的关键在于开发者可以在运行时改变函数的行为，也就是我们常说的<strong>Swizzling</strong>。Swizzling经常用来配置服务以及hook某些测试case。</p>
<div class="note info"><p>KVO就是使用swizzling实现的。</p></div>

<p>这种派发方式的流程步骤似乎很多，所幸的是objc_msgSend会将匹配的结果缓存到<strong>fast map</strong>中，而且每个类都有这样一块缓存；若是之后发送相同的消息，执行速率会很快。</p>
<h1 id="Swift如何派发函数"><a href="#Swift如何派发函数" class="headerlink" title="Swift如何派发函数"></a>Swift如何派发函数</h1><p>了解了函数派发的基本知识，我们来看看Swift如何处理函数派发以及如何证明该种派发。我们先来看一张总结表:</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1559823253/blogImages/Swift_Dispatch/table_fbcuhz.png"></p>
<p>从上表中我们可以直观的总结出：<strong>函数的派发方式和以下两点相关联:</strong></p>
<ol>
<li>对象类型; 值类型总是使用直接派发(静态派发，因为他们没有继承体系)</li>
<li>函数声明的位置; 直接在定义中声明和在扩展中(extension)声明</li>
</ol>
<p>除此之外，<strong>显式的指定派发方式</strong>也会改变函数其原有的派发方式，例如添加<strong>final或者@objc关键字等等</strong>；以及<strong>编译器对特定函数的优化</strong>，例如将从未被重写的私有函数优化成静态派发。</p>
<p>下面我们就这四个方面来分析和探讨Swift的派发方式，以及证明其派发方式。</p>
<h2 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h2><p>如上文所述，值类型，也就是struct的对象总是使用静态派发; class对象使用函数表派发(非extension)。请看如下示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    func testOfClass() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct myStruct &#123;</span><br><span class="line">    func testOfStruct() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们使用如下命令将swift代码转换为SIL(中间码)以便查看其函数派发方式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swiftc -emit-silgen -O test.swift</span><br></pre></td></tr></table></figure>

<p>输出结果如下:、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sil_vtable MyClass &#123;</span><br><span class="line">  #MyClass.testOfClass!1: (MyClass) -&gt; () -&gt; () : @$s4test7MyClassC0a2OfC0yyF	// MyClass.testOfClass()</span><br><span class="line">  #MyClass.init!allocator.1: (MyClass.Type) -&gt; () -&gt; MyClass : @$s4test7MyClassCACycfC	// MyClass.__allocating_init()</span><br><span class="line">  #MyClass.deinit!deallocator.1: @$s4test7MyClassCfD	// MyClass.__deallocating_deinit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先swift会为class添加<strong>init</strong>和<b>@objc deinit</b>方法，为struct添加<strong>init</strong>方法。在文件的结尾处就会显示如上代码，它展示了哪些函数是函数表派发的，以及它们的标识符。由于struct类型仅使用静态派发，所以不会显示sil_vtable字样。</p>
<h2 id="函数声明位置"><a href="#函数声明位置" class="headerlink" title="函数声明位置"></a>函数声明位置</h2><p>函数声明位置的不同也会导致派发方式的不同。在Swift中，我们常常在extension里面添加扩展方法。根据我们之前总结的表格，通常extension中声明的函数都默认使用静态派发。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protocol MyProtocol &#123;</span><br><span class="line">    func testOfProtocol()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension MyProtocol &#123;</span><br><span class="line">    func testOfProtocolInExtension() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyClass: MyProtocol &#123;</span><br><span class="line">    func testOfClass() &#123;&#125;</span><br><span class="line">    func testOfProtocol() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension MyClass &#123;</span><br><span class="line">    func testOfClassInExtension() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们分别在<strong>protocol</strong>和<strong>class</strong>中声明一个函数，再在其extension中声明一个函数; 最后让类实现协议的一个方法，转换成SIL代码后如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sil_vtable MyClass &#123;</span><br><span class="line">  #MyClass.testOfClass!1: (MyClass) -&gt; () -&gt; () : @$s4test7MyClassC0a2OfC0yyF	// MyClass.testOfClass()</span><br><span class="line">  #MyClass.testOfProtocol!1: (MyClass) -&gt; () -&gt; () : @$s4test7MyClassC0A10OfProtocolyyF	// MyClass.testOfProtocol()</span><br><span class="line">  #MyClass.init!allocator.1: (MyClass.Type) -&gt; () -&gt; MyClass : @$s4test7MyClassCACycfC	// MyClass.__allocating_init()</span><br><span class="line">  #MyClass.deinit!deallocator.1: @$s4test7MyClassCfD	// MyClass.__deallocating_deinit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sil_witness_table hidden MyClass: MyProtocol module test &#123;</span><br><span class="line">  method #MyProtocol.testOfProtocol!1: &lt;Self where Self : MyProtocol&gt; (Self) -&gt; () -&gt; () : @$s4test7MyClassCAA0B8ProtocolA2aDP0a2OfD0yyFTW	// protocol witness for MyProtocol.testOfProtocol() in conformance MyClass</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以很直观的看到，声明在协议或者类主体中的函数是使用函数表派发的; 而声明在扩展中的函数则是静态派发。</p>
<div class="note warning"><p>值得注意的是: 当我们在protocol中声明一个函数，并且在protocol的extension中实现了它，而且没有其他类型重写该函数，那么在这种情况下，该函数就是直接派发，算是通用函数。</p></div>

<h2 id="指定派发方式"><a href="#指定派发方式" class="headerlink" title="指定派发方式"></a>指定派发方式</h2><p>给函数添加关键字的修饰也能改变其派发方式。</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>添加了final关键字的函数无法被重写，使用直接派发，不会在vtable中出现。并且对Objc runtime不可见。</p>
<h3 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h3><p>值类型和引用类型的函数均可添加dynamic关键字。在Swift5中，给函数添加<strong>dynamic</strong>的作用是为了赋予非objc类和值类型(struct和enum)动态性。我们来看如下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Test &#123;</span><br><span class="line">    dynamic func test() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们赋予了test函数动态性。将其转换成SIL中间码后如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Test.test()</span><br><span class="line">sil hidden [dynamically_replacable] @$s4test4TestVAAyyF : $@convention(method) (Test) -&gt; () &#123;</span><br><span class="line">// %0                                             // user: %1</span><br><span class="line">bb0(%0 : @trivial $Test):</span><br><span class="line">  debug_value %0 : $Test, let, name &quot;self&quot;, argno 1 // id: %1</span><br><span class="line">  %2 = tuple ()                                   // user: %3</span><br><span class="line">  return %2 : $()                                 // id: %3</span><br><span class="line">&#125; // end sil function &#x27;$s4test4TestVAAyyF&#x27;</span><br></pre></td></tr></table></figure>

<p>我们在第二行可以看到<strong>test</strong>函数多了一个“属性”: <strong>dynamically_replacable</strong>, 也就是说添加dynamic关键字就是赋予函数<strong>动态替换</strong>的能力。那什么是动态替换呢? 简而言之就是提供一种途径，比方说，可以将Module A中定义的方法，在Module B中动态替换，如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Module A</span><br><span class="line">struct Foo &#123;</span><br><span class="line"> dynamic func bar() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Module B</span><br><span class="line">extension Foo &#123;</span><br><span class="line">  @_dynamicReplacement(for: bar()0</span><br><span class="line">  func barReplacement() &#123;</span><br><span class="line">    ...</span><br><span class="line">    // Calls previously active implementation of bar()</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>添加dynamic关键字并不代表对Objc可见。</p></div>

<h3 id="objc"><a href="#objc" class="headerlink" title="@objc"></a>@objc</h3><p>该关键字可以将Swift函数暴露给Objc运行时，但并不会改变其派发方式，依旧是函数表派发。举例如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    @objc func test() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SIL代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">// @objc Test.test()</span><br><span class="line">sil hidden [thunk] @$s4test4TestCAAyyFTo : $@convention(objc_method) (Test) -&gt; () &#123;</span><br><span class="line">// %0                                             // user: %1</span><br><span class="line">bb0(%0 : @unowned $Test):</span><br><span class="line">  %1 = copy_value %0 : $Test                      // users: %6, %2</span><br><span class="line">  %2 = begin_borrow %1 : $Test                    // users: %5, %4</span><br><span class="line">  // function_ref Test.test()</span><br><span class="line">  %3 = function_ref @$s4test4TestCAAyyF : $@convention(method) (@guaranteed Test) -&gt; () // user: %4</span><br><span class="line">  %4 = apply %3(%2) : $@convention(method) (@guaranteed Test) -&gt; () // user: %7</span><br><span class="line">  end_borrow %2 : $Test                           // id: %5</span><br><span class="line">  destroy_value %1 : $Test                        // id: %6</span><br><span class="line">  return %4 : $()                                 // id: %7</span><br><span class="line">&#125; // end sil function &#x27;$s4test4TestCAAyyFTo&#x27;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">sil_vtable Test &#123;</span><br><span class="line">  #Test.test!1: (Test) -&gt; () -&gt; () : @$s4test4TestCAAyyF	// Test.test()</span><br><span class="line">  #Test.init!allocator.1: (Test.Type) -&gt; () -&gt; Test : @$s4test4TestCACycfC	// Test.__allocating_init()</span><br><span class="line">  #Test.deinit!deallocator.1: @$s4test4TestCfD	// Test.__deallocating_deinit</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以看到test方法依旧在“虚函数列表”中，证明其实函数表派发。如果希望test函数使用消息派发，则需要额外添加<strong>dynamic</strong>关键字。</p>
<h3 id="inline-or-static"><a href="#inline-or-static" class="headerlink" title="@inline or static"></a>@inline or static</h3><p>@inline关键字顾名思义是想告诉编译器将此函数直接派发，但将其转换成SIL代码后，依旧是vtable派发。Static关键字会将函数变为直接派发。</p>
<h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><p>Swift会尽可能的去优化函数派发方式。我们上文提到，当一个类声明了一个私有函数时，该函数很可能会被优化为直接派发。这也就是为什么当我们在Swift中使用<strong>target-action</strong>模式时，私有selector会报错的原因(<em>Objective-C 无法获取 #selector 指定的函数</em>)。</p>
<h2 id="派发总结"><a href="#派发总结" class="headerlink" title="派发总结"></a>派发总结</h2><p>最后我们用一张图总结下Swift中的派发方式:</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1560241856/blogImages/Swift_Dispatch/summary_c0azo8.png"></p>
<p>从上表可见，我们在类型的主体中声明的函数大都是函数表派发，这也是Swift中最为常见的派发方式；而扩展大都是直接派发；只有再添加了特定关键字后，如**@objc, final, dynamic**后，函数派发方式才会有所改变。除此之外，编译器可能将某些方法优化为直接派发。例如私有函数。</p>
<h1 id="如何选择派发方式"><a href="#如何选择派发方式" class="headerlink" title="如何选择派发方式"></a>如何选择派发方式</h1><p>讲了这么多函数派发的方式，那对我们有什么用呢？或者说如何选择派发方式呢？</p>
<p>我总结了两点:</p>
<ol>
<li>帮助我们理解一些“奇怪的”行为，例如为何extension中的函数无法被子类继承，为何需要添加@objc甚至是dynamic后才能被重写。</li>
<li>提供选择类型的条件，例如您的app对性能要求很苛刻，那尽量使用值类型；并且对引用类型方法添加关键字描述。</li>
</ol>
<p>总的来说，如何选择还是取决于业务类型。首先要确定使用引用类型还是值类型，因为它们也部分决定了函数的派发方式；之后确定是否给函数添加关键字，例如<b>@objc，final或dynamic</b>，以达到准确描述该函数的目的。</p>
]]></content>
      <categories>
        <category>底层原理</category>
        <category>开发基础</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>开篇</title>
    <url>/2019/04/19/%E5%BC%80%E7%AF%87%E5%AF%84%E8%AF%AD/</url>
    <content><![CDATA[<h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><p>我是一名移动开发者，也做Web和混合开发，目前有6年的开发经验。</p>
<p>最早接触的是iOS开发， 那是在大三尾巴上的时候，那个暑假去魅族实习，挣了万把块钱，就”败了”一台MBP 13。当时买它的主要原因还不是想做Apple的开发，是源于我们的Team Lead。他从微软回来后加盟的魅族，也在微软做过Scrum Master, 带领团队。他提到在美国，老美们都用Mac开发，说它是开发利器，加上我们当时做Ruby on Rails，每次看他”秀”终端操作和工具的时候，总觉得那才是一个开发应该有的样子。当然你用其他系统一样可以开发，一样可以使用终端操作。除此之外，我还想学iOS开发，毕竟魅族当时也被誉为”中国的Apple”，我们的产品经理也是苹果粉，天天在爱范儿关注着各类信息。就这样，在他们的持续熏陶下，我踏上了iOS开发的道路。</p>
<span id="more"></span>

<p>整个大四一年算是学习iOS的入门阶段，尤其是刚开始，完全搞不懂内在逻辑，只能把别人代码拿下来，跑通了就算谢天谢地了。就这样断断续续的学习，直到本科毕业。毕业后加入了一家旅游公司，算是腾讯系，一开始在里面做Java，负责优化网站搜索引擎，有深度，但是很枯燥。做了一个月后，本来我以为我就要在Java的道路上一去不复返时，公司来了两个iOS开发，负责移动端的研发工作。那时的我就像发现救命稻草一样，赶紧和领导商量能不能调去移动组。领导也很快答应了。刚来的移动负责人<strong>增民</strong>也很开心，毕竟又多一个”小弟”，而且还做过一段时间iOS，上手应该很快。没成想上手开发才知道我对很多知识点还是一知半解，写出的代码用他的话说就是”out of control”。但他依旧没”放弃”我，让我和另一个iOS开发(Matt, 从PHP转行过来)一起正式开始了iOS的升级打怪之路。</p>
<p>就这样过了半年，我从一个行业小白慢慢踏进了这行的门，理解了基本的UI开发，熟悉了UIKit。我们三个也成了好朋友，虽说那时候(2014年)我们公司就开始实行996，但我们还是会在有限的时间内一起出去搞团建。直到现在我们依旧联系，聊聊技术，聊聊国内的生活。也是从那时起，我开始写博客，不过没坚持多久我就离职了，收拾好行囊奔赴新西兰求学。</p>
<p>来了新西兰用了半年时间(有效读书时间)拿下研究生学位，并在读书期间和奥大教育系合作，开发了一款教学App; 还找到了一份移动开发工作(local本地公司)，之后顺利拿下了绿卡。之后就跳槽到现在的公司，目前是Fiserv高级移动开发兼Scrum Master。</p>
<h1 id="重开博客"><a href="#重开博客" class="headerlink" title="重开博客"></a>重开博客</h1><p>写这篇博客的时候我已经28岁了，国内很多这个年龄的开发已经开始转管理岗了。相比国内，国外好些，做开发的生命周期长点，新西兰公司也不太在乎你的年纪，干的动你就干。但即将30岁，我总得想清楚自己以后的路怎么走，要成为什么样的人。移动开发是我的本职工作，自然要精，但怎样算精？学习无止境，时间有限，不要瞎学。</p>
<p>移动开发最火的时候已经过去，现在网上不少iOS开发抱怨不好找工作了，拿不到那么高的工资了。但细细分析就会发现这群人中大部分都做着和刚入行差不多的事情，也基本都局限在UI的开发上; 网络，本地存储，线程这些基本的操作也都局限在会用而已。那如何才能摆脱这种困境，完成iOS的进阶呢？</p>
<p>笔者认为，一个优秀的iOS开发，必然不仅仅局限在iOS的世界中。与其相关的任何技术，都应该有所积累和个人见解，并且善于总结，iOS的世界很宏大，为了避免无效的积累，有一套自我学习的标杆和方向是格外重要的。以下知识点就是我总结的iOS进阶之路知识体系。</p>
<ul>
<li>开发基础/进阶(Cocoatouch Frameworks, Runtime, 编译, 内存, 线程等)</li>
<li>测试(Unit/UI Test, PEN Testing, Performance Test, TDD等)</li>
<li>架构(MVC, MVVM, MVP，响应式编程)</li>
<li>CI/CD(DevOps, Jenkins, fastlane, 以及一些轻量级工具等)</li>
<li>网络(服务器的实现，缓存优化，认证及安全等)</li>
<li>存储(沙盒机制，持久化方案，Keychain)</li>
<li>安全(本地数据保护，网络安全，反编译和代码混淆)</li>
<li>多媒体(音频，视频，图形图像)</li>
<li>版本控制(Git, Code Review等)</li>
<li>证书(原理，重新签名等)</li>
<li>优化(统计埋点，App瘦身，电量优化等)</li>
<li>跨平台方案(Flutter, RN, 实现原理)</li>
<li>智能时代(ARKit, CoreML)</li>
<li>软实力提升(敏捷开发，项目管理)</li>
<li>Android开发</li>
</ul>
<div class="note info"><p>网上有很多iOS知识体系的脑图，大家也可以参考。重要的是找到适合自己学习路线，将平日的学习有的放矢的归类。</p></div>

<h1 id="博客的宏观路线"><a href="#博客的宏观路线" class="headerlink" title="博客的宏观路线"></a>博客的宏观路线</h1><p>笔者的博客名: <strong>Full Stack Mobile Developer</strong>。看上去可能不好理解。我在此稍作解释。就如我上文提到的: <strong>一个优秀的移动开发，必然不仅仅是局限在移动的世界中。</strong>无论是网络知识还是安全知识，都应该有涉猎，并有自己的一套解决问题的逻辑, 技术选型，风险评估等等。总而言之就是: 对于移动开发，从产品的设计到发布这个过程中，你能提供所有环节的技术支持和团队管理能力。这些如果都能很好地完成，那么这名移动开发就可以称为”全栈移动开发”，而且满足无论是组长还是技术组长的考核要求。</p>
<p>本博客就建立在这个目标之上，之后的文章也都会归属于以上的大类。同时我也会维护一个github仓库，把博客涉及到的代码资源公开，以方便读者们学习和交流。</p>
]]></content>
      <categories>
        <category>知识体系</category>
        <category>软实力</category>
      </categories>
      <tags>
        <tag>自我总结</tag>
      </tags>
  </entry>
  <entry>
    <title>《格鲁夫给经理人的第一课》读书笔记</title>
    <url>/2020/07/23/%E6%A0%BC%E9%B2%81%E5%A4%AB%E7%BB%99%E7%BB%8F%E7%90%86%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E8%AF%BE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在职场，越往上走，越觉得管理是门学问。很好奇我的开发经理(Dev Manager)是如何工作的，他们每年给我们这些 “一线开发” 制定KPI，那他们的KPI是如何定义的，他们的产出在哪里？平时他们除了开会，就是回复邮件，这些真的能带来产出么？带着这些疑问，我淘到了一本英特尔前CEO格鲁夫写的一本 《High Output Management》, 里面详细介绍了如何衡量一个经理人的产出以及如何提升其产出的方法，令我感触颇多。这本书也帮助我理解了公司和团队日常开不同会议的目的和作用，以及经理人在其中的角色。</p>
<span id="more"></span>

<h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h1><p>这本书主要聚焦于企业中的中层经理人，教导他们如何提升自己的产出，管理好自己的团队。首先 <strong>中层经理</strong>并不是一个具体的title，他可以是一名工程师，或是会计师，无论怎样，他都是一个组织的骨干。</p>
<p>这本书的中心是围绕 <strong>产出导向</strong> 这四个字展开的。企业需要产出和利润，在这个目标的驱动下，企业中的每个人都需要产生对应的产出，这里面中层经理人的贡献是不可忽视的，他们就如同一支润滑剂，无缝衔接着决策层和工程师团队。产出导向主要涵盖以下三个方面:</p>
<ol>
<li>经理人产出定义和优化</li>
<li>生产法则</li>
<li>团队意识 + 个人意识</li>
</ol>
<p>虽说英特尔是个制造业公司，但格鲁夫提出的这些概念其实在互联网公司也得到了很广泛的应用。只不过互联网公司架构更加扁平，也有业内约定俗成的一套方式方法，例如各种Agile的实践，ceremonies等。但万变不离其宗，都是为了解决公司内部流程的问题，从而提高整个公司的产出。</p>
<h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><p>下面我们从三个维度(why, what and how)来展开 <strong>产出导向</strong> 这个核心概念。</p>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>为什么我们强调产出? 结论应该是显而易见的: <strong>往低说是保住饭碗; 往高说是获得更多晋升的机会，帮助公司创造更多的价值; 往远说更是帮助自己提升职场的竞争力</strong>。</p>
<p>格鲁夫在写这本书的时候说:</p>
<div class="note warning"><p>今天，处在人生中场的中年中层干部，失业的可能性大约是十年前的两倍。我观察身边的EMBA朋友们的职场动态，状况还可能越来越糟。其实我们不是任何“老 板”的员工，我们每个人都是自己职业生涯的员工。没人欠我们一个饭碗，你必须自己当家。认清只有你自己(不是你的“老板”)才是自己的主人。为打赢越来越 激烈的“保职战”，我们得好好提升自己的“产能”，增加自己的附加价值与生产力，不能有丝毫懈怠。一天24小时我们都该竭尽全力追求进步。</p></div>

<p>这段话在今天(2020)也显得格外应景和睿智。在Covid-19疫情下, 无数企业忙着裁员和重组，大量人员失业。在新西兰，甚至空姐都得去超市做货架员。在这种极端情况下，我们不得不去思考我们自己的定位，我们自己的产出是什么，我们的核心竞争力又在那里？</p>
<h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><h3 id="经理人的产出"><a href="#经理人的产出" class="headerlink" title="经理人的产出"></a>经理人的产出</h3><p>那产出导向是什么呢? 如何定义一个人的产出? 下面我们就来用格鲁夫的公式来解释一个经理人的产出, 同样，也适用于我们自己。</p>
<div class="note info"><p>经理人的产出=组织产出加总=a×A+b×B+c×C+...(a、b、c......代表管理杠杆率，A、B、C......代表各种管理活动.)</p></div>

<p><strong>经理人产出是由两部分构成的: <b>直接管辖和间接影响力所及的组织产出加总.</strong></p>
<p>先来解释下名词:<br><strong>杠杆率: 各单项管理活动所带来的产出, 可以理解为单位产出.</strong><br><strong>管理活动: 可以理解为管理总量.</strong></p>
<p>这个公式很好理解，每个经理人手下不止一个团队，每个团队也不止一个管理活动。当然，这些管理活动的定义是视情况而定的。举例来说，我们team现在的Delivery Manager直接管理着两个团队: 一个产品团队, 一个SDK团队. 产品团队对SDK团队有依赖; 由于我们的后台服务依赖Core Platform, 所以我们的经理还得经常和Core Platform的经理开会。除此之外，前台产生的数据最终需要数据/AI团队整理并生成报告送给客户, 所以我们也得经常和AI团队交流，确保数据的完整和准确。所以我们经理的产出总和就是直接管理的俩团队的产出总和加上间接影响到的Core Platform以及AI团队的产出。至于每个管理活动的杠杆率和管理活动总量我们无需纠结，只要知道他们代表什么就够了，因为在软件行业我们不这么定义产出，而是使用Agile的方式方法定义，例如scrum，我们有team velocity和spring goal，以及一系列的Agile ceremonies确保团队产出的稳定。</p>
<h3 id="生产法则"><a href="#生产法则" class="headerlink" title="生产法则"></a>生产法则</h3><p>在这点上，制造业和软件开发相似性很高。格鲁夫是这样定义生产的:</p>
<div class="note info"><p>按预定的时间、可接受的品质以及可能的最低成本，依据顾客的需求制造及运送产品。</p></div>

<h4 id="流程和限制步骤"><a href="#流程和限制步骤" class="headerlink" title="流程和限制步骤"></a>流程和限制步骤</h4><p>完全和我们交付产品给公司或是客户的要求一模一样！英特尔的生产步骤可以总结如下:</p>
<ol>
<li>**制造: **营销和研发人员将一大堆的产品资料化为业务人员理解的销售策略，这个将资料转化成策略的过程便是制造.</li>
<li>**组装: **将各种销售策略组合成完美的销售计划。在新产品上市的会议上，营销人员将最合适的策略和必要的市场资料(如竞争商品的价格和存货状况)结合产品说明、宣传册及活动挂图向业务人员报告。</li>
<li>**测试: **在真正上市之前应先有一场虚拟的上市发布会。在此会议上，被挑选出来的业务代表要对策略及销售工具等等作出反应。如果反映不佳，亦即测试结果不良，整个策略就必须修改或重新制定，以符合原定的营销及销售目标.</li>
</ol>
<p>软件开发也有流程，就是我们熟悉的<strong>SDLC</strong>:</p>
<p>1.<strong>计划</strong>: 明确需求, 设定交付时间线.<br>2.<strong>分析</strong>: 调研, 定义目标，例如项目目标以及产品的功能和操作.<br>3.<strong>设计</strong>: 流程图，架构图，UI设计，伪代码，文档，商业逻辑等.<br>4.<strong>实现</strong>: 功能实现.<br>5.<strong>测试以及集成</strong>: 单元测试，回归测试，烟雾测试等，集成系统，部署.<br>6.<strong>维护</strong>: 发布后线上监控, 修复问题等.</p>
<p>在生产法则中，格鲁夫强调了一个很重要的概念: <strong>限制步骤</strong>。 流程中其他的步骤都是围绕这个限制步骤展开的，可以将<strong>限制步骤</strong>理解为最耗时，成本最大的一个步骤。那软件开发中限制步骤是什么呢？个人认为是<strong>实现阶段</strong>，即开始写代码的阶段。大多数情况下，在软件开发过程中，人工都是最贵的，一旦项目开始，就很难走回头路了。所以围绕<strong>实现</strong>前的3个步骤一定要仔细调研，给出清晰地需求和设计，而且要先做MVP(<em>Minimum Viable Product</em>); 在开发团队实现MVP的过程中，PO(<em>Product Owner</em>), BA(<em>Business Analyst</em>)要开始准备下一阶段的需求会议以及设计，这就是实现了<strong>时间互偿</strong>。</p>
<h4 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h4><p>这其实就是我们在平时工作中的 “Spint Goal”。一个Sprint一般是两周，也就是说在两周中，team要完成定量的工作，如果没有完成，即是没有达标。在Scrum中，每个team都有其 “Velocity”，例如每个Sprint是58，即两周时间，这个team可以完成58个story point。PO就可以根据team的速率来决定下一个Sprint要commit多少个point。<br>有了指标才好评判一个team是否有稳定的产出，也容易帮助经理发现和解决问题，从而提高他们管理活动的杠杆率。</p>
<h4 id="杠杆率"><a href="#杠杆率" class="headerlink" title="杠杆率"></a>杠杆率</h4><p>一个活动如果有比较高的杠杆率，即表示同样的投入之下，这项活动会比杠杆率较低者有更高的产出。</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1595818747/blogImages/high_output_management/leverage_si2vnc.png"></p>
<p>这个反应在我们日常的工作中就是事物的优先级(Priority)。优先级高的，自然是对公司重要的，势必要给公司带来更大的产出，或者减少极大的成本开支。在日常的生产，或是开发过程中，经理人要发力在那些能给自己带来最大产出的工作上，这也符合公司的宏观目标。比方说：公司P有两个项目A和B，当A项目第一阶段告落得时候，公司要决定是继续投钱在A项目还是把重心移到客户更需要的B项目。结论显而易见，公司选择了B项目，那么经理人就需要把他的时间更多的放在B项目上，A项目每周查看几次就可以了，确保不会出现大问题即可。</p>
<h3 id="团队意识-个人意识"><a href="#团队意识-个人意识" class="headerlink" title="团队意识 + 个人意识"></a>团队意识 + 个人意识</h3><p>“单丝不成线，孤木不成林”。经理人要想 “成事” 离开团队是绝对不行的，而且经理人产出的公式已经很好地反映出了这一点：产出都是团队合作的结果。</p>
<p>说到团队合作，我相信一线的工程师们肯定有很多想吐槽和质疑的点，甚至会有人觉得团队合作就是笑话，还不如自己一个人效率高等等。这种想法其实就是把自己限制在了工程师这个角色中，而不是跳脱出来站在一个更高的高度上看问题。人类世界，大部分生产活动都需要团队合作才能成功。我们开发产品，也要时刻记着我们的目的：<strong>按预定的时间、可接受的品质以及可能的最低成本，依据顾客的需求制造及运送产品, 而不是完成每一个特定的功能</strong>. 单兵作战能力再强，也敌不过对手聚而攻之。如果发现团队里有成员带不动，或者合作有问题的时候，我们是需要去解决他们个人的问题，而不是否定团队合作。</p>
<p>所以，除了团队合作外，个人意识也很重要。每个团队成员都需要<strong>各司其职，各尽所能</strong>, 才能保证团队有最高的产能。格鲁夫举了这样一个例子：</p>
<div class="note warning"><p>不管教练再怎么强，仍然得看队员们的努力，就像在球场上运球、上篮还是得靠球员的表现。</p></div>

<p>格鲁夫认为：如果一个人没有做好他的事，只有两种原因可以解释，要么是<strong>不为</strong>，要么就是<strong>不能</strong>。前者是态度有问题，缺乏诱因；后者则是无能为力。对于后者，大部分情况团队内的成员们会互相帮助，共同克服困难。如果真是因为能力不济，那么就要反思招聘和培训流程的问题。至于第一种情况，若是缺乏诱因，那么可以对症下药，找到激励员工的方法；如果员工就是 “老油条”，那么就要考虑绩效评估，多劳多得，保证一碗水端平。</p>
<p>只有做到 “点对点” 的沟通，经理人才能更好地了解团队的情况，针对不同成员制定不同的策略，最终保证的是整个团队的高产出。这也是为什么国外互联网公司经常有员工和经理(或者组长) “一对一” 的会议，就是确保沟通顺畅，及时解决问题。</p>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>我们已经知道了产出导向的含义，那如何提升它们呢？我们先前已经知道经理人产出的公式：</p>
<div class="note info"><p>经理人的产出=组织产出加总=a×A+b×B+c×C+...(a、b、c......代表管理杠杆率，A、B、C......代表各种管理活动.)</p></div>

<p>那具体方法也很明确：</p>
<ol>
<li>安排好管理活动的优先级，剔除低杠杆率的管理活动，代之以高杠杆率的活动</li>
<li>提升每一项管理活动的杠杆率</li>
</ol>
<p>经理人每天要从事很多活动，需要区分清楚哪些能带来产出，哪些不能；并根据公司的目标，将高产出的管理活动放在优先级较高的位置上，确保团队优先执行。例如：每个sprint的planning，和refinement是必须放在高优先级的位置上的，因为这两个会议决定了当前这个sprint要产出和能产出什么。除了给管理活动排序，经理人也要知道如何提升高优先级管理活动的杠杆率，例如提升sprint planning和refinement的效率。</p>
<p>经理人要在开这两个会前做好充足的准备，或者让负责会议的product owner做好充足的准备，不要在会议中还在补充backlog中的task；经理人也要在会议前及时解决或者反馈团队遇到的阻碍，这样方便团队合理安排capacity(每个人每个sprint的时间)。经理人也要及时决策，不要犹豫不决，这样有可能会影响团队士气，导致效率低下。总之还有很多提升管理活动杠杆率的方法，核心就在于要和团队及时沟通，及时解决各种问题，这样每个管理活动的效率才能令人满意。</p>
<h3 id="让流程的每个环节可控"><a href="#让流程的每个环节可控" class="headerlink" title="让流程的每个环节可控"></a>让流程的每个环节可控</h3><p>软件开发有计划，分析，设计，实现，测试和维护几个步骤. 每个步骤都应该严格控制完成时间，以确保<strong>限制步骤</strong>有充足的时间去执行，不能无休止的去计划和设计。举个亲身经历的案例：我们公司要做一款 “Server-Driven”的移动端产品, 我们称之为 “white label app”, 意思就是任何一个客户接入时，我们不需要大量修改我们的代码库，只需要修改针对不同客户的配置文件就能自动生成专属于该客户的移动端产品。理念任何人都能理解，但是架构设计却没有一个人能够(愿意)去拍板决定，所以我们当时的经理带着我们连续和不同高层开了一个月的会，把“white label”的概念讲了一遍又一遍，最终还是我们自己做了决定。这样下来前前后后浪费了一个月的开发时间，也让一线开发们参加了很多不必要的会议。</p>
<p>这就是典型的没有把控好软件开发流程的一个例子，做了很多杠杆率不高的事情，导致产品推迟了发布。其实每个步骤都可以建立指标，例如产品设计我们要在两周之内完成，出多少张原型图，这些都是可以量化的。像英特尔有 <strong>先行指标，线性指标，趋势指标等等</strong>， 软件开发流程也可以借鉴，避免做重复无用功。</p>
<h3 id="管理的必经之路-开会"><a href="#管理的必经之路-开会" class="headerlink" title="管理的必经之路: 开会"></a>管理的必经之路: 开会</h3><p>格鲁夫将开会分为两大类: <strong>任务导向型会议和过程导向型会议</strong>.</p>
<div class="note warning"><p>会议是从事管理工作必经的媒介,你绝对无法避免开会，但你能让会议更有效率.</p></div>

<p>任务导向型会议通常是产生决策的会议，这类会议杠杆率很高，例如Sprint Planning，在这种会议上，团队要制定下个Sprint要完成的任务，决定产出；过程导向型会议通常是一些知识分享，注重与会者过程中学到什么，例如我们经常举办的 “lunch and learn”，分享一个话题，大家一起讨论，分享。这类会议有时也可以显著提升团队或者个人的产出效率，例如一些团队内部知识分享，能有效打破知识壁垒，也利于内部成员了解一些架构设计，避免日后返工。</p>
<p>以上是针对团队的会议，那针对个人呢？其实产出最终都会落到每个人的头上，经理人也需要市场关注团队内每个个体员工的日常工作情况。所以 “一对一” 会议就应运而生了。</p>
<p>一对一会议经常由经理或者是你的team lead来主持，大概每两周或者每个月举行一次。内容基本上就是询问你的近况，有没什么问题和担忧；如果临近绩效考核，还会和你谈谈绩效的问题。总之作为经理人，你要在一对一会议上想办法让部属把觉得心烦的事情说出来，这样才能帮助他们去解决，从而提升工作效率。要做好一个倾听者，集学生和教练的角色于一身，做好笔记，让部属觉得你很重视他们的反馈，这样才能提升一对一会议的效率，你也做了存档，避免忘记。</p>
<p>一对一会议的杠杆率是巨大的，试想你和部属每个两周开一次一对一会议，30分钟，就会影响他接下来两周，也就是80个小时的工作成果；如果在一对一会议中你们能建立和加强你们之间的信任关系，那对产出的提升是事半功倍的。同时，你也能了解部属的工作，建立共同的信息基础。</p>
<h3 id="培训与激励-绩效"><a href="#培训与激励-绩效" class="headerlink" title="培训与激励(绩效)"></a>培训与激励(绩效)</h3><p>相信这是大部分一线开发都经历过的事情：入职培训和绩效考核。入职培训个人感觉杠杆率不高，基本是走个过场；但技术培训则不同，杠杆率极高。比方说我入职F公司，进去第二天就接受了当时项目架构的培训，对我之后的工作的确是起了事半功倍的效果，阅读代码也能更快的理解含义，最终出活儿的速度和质量都得到了显著提升。</p>
<div class="note info"><p>很明显，培训员工具有极高的管理杠杆率。举个例子，如果你必须为你的部门上4堂课，假设每堂1小时的课你要花3小时准备，那么你花在这次培训上的时间是16小时。你的部门如果有10个人，第二年他们在公司的工作时间将大约在2万小时左右。如果你的培训能将部属的绩效提高1个百分点，对公司而言便是多了200小时——而这只是你花了16小时的结果。没有受到良好培训的员工就算再怎么努力，结果仍然会是缺乏效率、成本增加、客户不满，有时甚至还会使公司陷入危机。</p></div>

<p>所以一个公司有完善的培训流程是很重要的，尤其是大公司，否则对新人来说是种折磨；对公司来说则可能造成极大的损失。</p>
<p>至于激励，我们的目的是用激励产生效能，也就意味着我们的激励要符合部署的内心。简单来说，有些人要钱，有些人要权，不只是权力，也有话语权。格鲁夫有句话讲的很好：激励是用来提高绩效的，而不是改变一个人的情绪或者态度。或许他的态度变积极，但是最终我们要看到新的产能出现。</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1595818747/blogImages/high_output_management/layers_l7t5zt.png"></p>
<p>就像治病救人一样，激励也是要对症下药。上图是著名的马斯洛需求理论。大部分员工是为了赚钱来工作的，那么公司就要满足最底层的需求，给员工至少每年和通胀差不多的工资涨幅；再高一层就是安全感，公司针对这部分员工可能需要提供保险补贴。我身边就有一个极好的例子，他选择的公司都是本地大企业(银行)，提供保险补贴，贷款优惠等，因为他有3个孩子，两位老人需要照顾，就职于这样的公司，隐性的福利大于工资的可能涨幅了；中间这层则是人类情感的需求，人们需要别人的认同，希望和志同道合的人在一起工作，也希望做的产品有价值甚至有趣；</p>
<p>至于剩下的两种需求，格鲁夫认为它们才是真正激励我们在工作上追求更卓越表现的原因。追求地位意味着你想在公司承担更多的责任和有更大的话语权，这点对于高级开发是极其重要的。高级做到一定年限后，你的下一个目标很可能就是带团队，做一个lead，这样可以让你跨越一个台阶，也会让你发现另一个不一样的世界。不过在现实生活中，升到一定阶段无法再升，或者达到了你升职的目标后，你的动力又会下降，会感觉没了前进的动力，这时候你就需要最顶层的 <strong>自我实现</strong>，只有它才能让你的工作动力不再受限，才能激励你不断向上突破。</p>
<p>格鲁夫具体介绍了两种内在动力：<strong>精益求精型和成就导向型</strong>. 我身边这两类朋友不在少数，第一种是iOS开发大神，自己做产品，给Apple亚洲区Unicode做贡献，不断向下钻研，人生理想是写出自己的编译器；第二种是不断的设定目标和达成任务，不断地在挑战自己的极限，完成一个又一个看似不可能的任务。</p>
<p>对于公司和经理人来说，个人觉得能做好前三点就很不错了，后两点个体差异太大，便不再多做讨论。经理人应该多了解部属，给予公平公正的奖惩，认证核实员工KPI，不要让员工寒心。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>刚工作的时候很不理解自我的价值在哪里，为什么我能拿这份钱，有市场行情的因素，但是我的产出又在那里？公司一线开发都是每天做着相同的工作，那绩效为何有高有低? 读完格鲁夫的书，我对这些疑问也大致有了答案，知道了我每个sprint出的feature和最终客户的销售业绩的联系，知道了自己的价值所在，为公司和客户赚了多少钱，知道了这些，我明白了我的产出，也明白了公司和经理安排这些考评流程和会议的意义所在，也知道了我自己时间的价值和我下一步的追求。总的来说有种拨开云雾，见到光明的感觉，很通透，很敞亮。也希望这篇文章能够帮助到你，对自己的产出有个大致认识和了解。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>管理</tag>
        <tag>Team Work</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS App启动的奥秘</title>
    <url>/2019/04/20/iOS%20App%E5%90%AF%E5%8A%A8%E7%9A%84%E5%A5%A5%E7%A7%98/</url>
    <content><![CDATA[<p>随着智能手机，平板在中国普及率的上升，人们越来越依赖移动设备进行娱乐、消费，由此催生出的App更是层出不穷。根据苹果2019年2月的数据，目前AppStore上的App数量已经超过220万，比2018年同期增长了近10万个App。2015年6月到2016年6月可谓是App发展的高速时期，仅仅一年时间就增长了50万个App；同时期也是中国互联网+的黄金时期，各种创业项目，平台推出了各式各样的移动App产品。</p>
<p>随着App的爆发式增长，我们越来越清晰地发现, 大多数App是无法长期停留在用户手机里的, 而今天这篇文章，我们将从一个<strong>开发者</strong>的角度来思考：如何提升用户体验，让我们的App在同类产品中脱颖而出，最终能够长期稳定的存在于用户手机之中。</p>
<div class="note warning"><p>每当我们说到用户体验，我们往往想到的是优化界面，交互方式等。这些固然重要，但这更多的是产品和UX的职责。作为开发，我们需要考虑他们无法完成的，更有技术导向的事情，比方说：<b>优化App的启动流程。</b></p></div>

<span id="more"></span>

<h1 id="为什么要考虑App的启动时间"><a href="#为什么要考虑App的启动时间" class="headerlink" title="为什么要考虑App的启动时间"></a>为什么要考虑App的启动时间</h1><p>这个问题乍看上去有点废话连篇的意思，哪个用户不希望App能够飞速的打开? 哪个公司不希望自己的App能有这样好的性能？但这个问题，其实质是希望帮助开发人员<strong>理顺业务、服务的初始化思路，以及构建项目的方式。</strong></p>
<p>在展开来说之前，我们需要定义下<strong>什么是App的启动：</strong></p>
<div class="note info"><p>通俗来讲，就是从用户点击App图标开始，到看到第一个页面的时间间隔。</p>细分来看，App的启动分两种：<b>冷启动</b>和<b>热启动</b>。<ul><li>冷启动：App启动前，内核没有为它分配相应的进程。</li><li>热启动：App冷启动后，用户将App退出至后台，再进入的过程。</li></ul></div>

<p>热启动没什么好说的，能做的通用的事情非常少。App从后台回来直接进入AppDelegate生命周期函数，剩下的就是App自身的业务逻辑，如果要优化，也仅是业务上的优化，恢复数据，做一些同步。所以本篇我们只展开讲冷启动(<strong>后文将用启动代替冷启动)<strong>的流程和优化。</strong>BTW:</strong> 笔者建议先从热启动开始优化，毕竟大部分的性能瓶颈都在自家代码里。</p>
<h1 id="App启动步骤概览"><a href="#App启动步骤概览" class="headerlink" title="App启动步骤概览"></a>App启动步骤概览</h1><p>从大方向讲，App启动步骤分为三个阶段：</p>
<ol>
<li>从系统 <strong>exec</strong> 函数调用到我们App的 <strong>main</strong> 函数为止 (main函数之前)</li>
<li><strong>main</strong> 函数执行之后</li>
<li>首屏渲染结束(至第一个界面的<span style="color:#c7254e">viewDidAppear</span>，Nib loading)</li>
</ol>
<p>整个流程如下：</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1556123094/blogImages/app_launch/app_launch_process_y7gp4w.png"></p>
<p>概括来讲：<strong>内核先将我们的App加载进内存，之后加载一个“中间件”: dynamic loader(简称:dyld)。之后dyld会负责分析App的Mach-O文件以加载所需的dynamic libraries。之后利用Rebasing和Binding修正内部和外部指针指向。最后加载runtime组件，runtime组件加载好后就会向需要初始化的object发送消息，开始初始化。</strong> 至此，main函数之前的步骤结束。之后的流程就是我们耳熟能详的生命周期了，App开始在AppDelegate里面初始化我们自定义的服务以及渲染首屏等。</p>
<h1 id="Crash-Course-名词速成班"><a href="#Crash-Course-名词速成班" class="headerlink" title="Crash Course (名词速成班)"></a>Crash Course (名词速成班)</h1><p>相信你看到这里或多或少已经对其中的一些名词感到陌生甚至”讨厌”了。这里面可能除了runtime，其他的你都没接触过。所以，这一小节我们针对上述流程涉及到的名词加以解释，并帮助大家扩充下底层知识，更好的理解main函数之前发生的事情。</p>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p>内核是操作系统的核心。iOS和OS X使用的都是XNU内核。在这里，我们不需要知道XNU内核的详细架构，只需要知道它的功能即可，例如：提供基础服务，像线程，进程管理，IPC(进程间通信)，文件系统等等。</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1556125886/blogImages/app_launch/kernel_otphqr.png"></p>
<p>上图阐述了内核是如何加载我们的App到进程中的。在这幅图里有两个关键点：</p>
<ol>
<li>PAGEZERO是怎么回事？</li>
<li>为什么我们的App起始位置是不确定的？</li>
</ol>
<p>这就要涉及到下一个知识点：<strong>ASLR</strong>。</p>
<h3 id="ASLR-地址空间布局随机化-Code-Sign"><a href="#ASLR-地址空间布局随机化-Code-Sign" class="headerlink" title="ASLR(地址空间布局随机化) + Code Sign"></a>ASLR(地址空间布局随机化) + Code Sign</h3><p>简单来说，就是当应用映射到逻辑地址空间的时候，利用ASLR技术，可以使得应用的起始地址总是随机的，以避免黑客通过起始地址+偏移量找到函数的地址。ASLR和Code Sign是iOS两种主要的安全技术。相信大家对Code Sign并不陌生，在底层上进行code sign的时候，加密哈希是针对Mach-O的每一个page，这就保证了dyld在加载Mach-O的时候可以确保单个page不被篡改。</p>
<p>那<strong>PAGEZERO</strong>的作用又是什么呢？当系统利用ASLR分配了随机地址后，从0到该地址的整个区间会被标记为不可访问，意味着不可读，不可写，不可被执行。这个区域的大小苹果给出了官方的解释：</p>
<ol>
<li>针对32位进程，至少4KB</li>
<li>针对64位进程，至少4GB</li>
</ol>
<p>这块区域可以帮助我们捕获任意的空指针和指针截断。(例如:64位指针转32位的时候)</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>理解了虚拟内存能够更好地帮助我们理解iOS内部机制。首先，现有的操作系统大都使用逻辑地址和物理地址这两个概念。逻辑地址可以理解为是虚拟地址，为的是”欺骗App”；但经过硬件和软件的配合，逻辑地址可以被映射到实实在在的物理地址上。</p>
<div class="note default"><p>逻辑内存是被分页的，就像一整块蛋糕被分成多个小块一样。然后通过页表，映射到物理内存。物理内存是被分为很多帧的，和逻辑内存的页相对应。(<b>页面和帧的对应关系主要是通过页表来保存</b>)</p></div>

<p>总的来说，逻辑地址空间(虚拟内存)大大提高了CPU的使用效率，使得多个程序可以被同时、按需加载进内存。</p>
<p>iOS中，每一个进程都是一个逻辑地址空间，并且同时映射到物理内存上。这种映射不只是一对一关系，还可以是<strong>一对0，多对一</strong>。 当逻辑内存地址在物理内存上没有对应的地址时，就会发生Page Fault错误。这时候内核就会停止当前线程，分配一块物理内存给当前的逻辑地址；如果我们有两个进程运行在不同的逻辑地址空间，它们是可以同时映射到同一物理内存的，这时候就需要它们share部分的RAM了。</p>
<p>那么问题来了，既然两个进程的某些逻辑地址空间可以同时映射到相同的物理地址，那么如果它们一方需要修改该地址内容的话，该如何是好呢？这就需要介绍下iOS的<b>Copy-On-Write(COW)</b>机制了。</p>
<div class="note warning"><p>当一个进程试图向DATA page写入数据时，内核会立刻创建一个拷贝，并映射到另一个物理RAM</p></div>

<p>至于什么是DATA page， 我们稍后在Mach-O章节介绍。</p>
<p>当<strong>Copy-On-Write</strong>发生的时候，会产生dirty page, 与之相对的则是clean page。Clean page是那种内核可以之后从磁盘恢复的拷贝；而dirty page则包含了进程信息，无法被其他进程重用。</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1556143096/blogImages/app_launch/dirty_page_cavdyh.png"></p>
<p>图中<strong>RAM 3</strong>所在的page就是一个dirty page。</p>
<p>在dyld章节我会再次提到clean page和dirty page，着重讲解dyld是如何通过修改Mach-O的__Data段，从而产生dirty page。</p>
<h2 id="Mach-O"><a href="#Mach-O" class="headerlink" title="Mach-O"></a>Mach-O</h2><p>Mach-O，全称是Mac object file format, 是一种文件类型。哪些文件是Mach-O呢？</p>
<ul>
<li><strong>Exectuable:</strong> 例如我们App bundle下的二进制文件</li>
<li><strong>Dylib:</strong> 动态库，好比Windows下的.dll</li>
<li><strong>Bundle:</strong> 指的是无法被链接，只能使用dlopen加载的动态库，例如Mac平台下的plug-ins</li>
<li><strong>Image:</strong> 以上三个</li>
<li><strong>Framework:</strong> 包含资源文件、头文件等的dylib</li>
</ul>
<h3 id="段-Segments"><a href="#段-Segments" class="headerlink" title="段(Segments)"></a>段(Segments)</h3><p>Apple的Mach-O文件可以分为三大部分：</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1556145524/blogImages/app_launch/macho_file_koolwz.png"></p>
<ol>
<li>Header: 头部， 包含可执行的cpu架构，文件类型等，例如arm64，x86；MH_EXECUTE。(如果合并过架构，则会是Fat Header)</li>
<li>Load commands: 加载命令，包含文件的组织架构和在虚拟内存中的布局方式</li>
<li>Data: 数据，包含load commands中需要的各个段(segment)的数据，每一个Segment的大小都是Page的整数倍。</li>
</ol>
<p>Data部分示意图:</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1556146160/blogImages/app_launch/macho_data_cizxtb.png"></p>
<p>上例中，TEXT段大小是3页，DATA和LINKEDIT各是一页。Page的大小取决于硬件的架构，例如在arm64<br>架构下，每页是16KB；其余架构下每页是4KB。</p>
<div class="note info"><p>Data部分包含哪些segment呢？绝大多数MachO包括以下三段:</p><ul><li><b>__TEXT: 代码段，只读，包括函数，和只读的常量，例如C字符串，上图中类似__TEXT, __text的都是代码段</b></li><li><b>__DATA: 数据段，读写，包括可读写的全局变量, 静态变量等，上图中类似__DATA, __data都是数据段</b></li><li><b>__LINKEDIT: 如何加载程序, 包含了方法和变量的元数据（位置，偏移量），以及代码签名等信息。</b></li></ul></div>

<p>下图是我个人项目NetworkTransport的Mach-O文件布局: 从图中可以清晰的看到__TEXT和__DATA. 那__LINKEDIT去哪里了呢？据我观察__LINKEDIT似乎被隐藏了，但是其存储的元数据却是可见的，例如下图中笔者选中的<strong>Dynamic Loader Info</strong>一栏，Rebase的信息一览无余的展现在我们面前。</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1556164832/blogImages/app_launch/macho_view_ofs7cx.png"></p>
<p>并且，当你展开<strong>Load Commands</strong>选项的时候，就会发现__LINKEDIT的段布局信息。</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1556165179/blogImages/app_launch/load_commands_fksg1b.png"></p>
<h3 id="部分-Sections"><a href="#部分-Sections" class="headerlink" title="部分(Sections)"></a>部分(Sections)</h3><p>Section是段(Segment)中的子区域, 每个section包含的内容不同，大小也没有限制。例如在__TEXT segment里， __text section包含的是可执行的机器码; __cstring section包含C类常量字符串。值得注意的是，这里面的常量是没有重复的，原因是静态连接器在做构建的时候，合并了有相同值的常量。</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1556265320/blogImages/app_launch/section_of_segment_zqokcw.png"></p>
<h3 id="PIC-Position-Independ-Code-code-gen"><a href="#PIC-Position-Independ-Code-code-gen" class="headerlink" title="PIC(Position Independ Code, code-gen)"></a>PIC(Position Independ Code, code-gen)</h3><p>在dyld拼接不同的dylibs的时候，dylib_A也需要知道如何调用dylib_B。但是由于每页都被签名的原因，dyld是无法直接去修改指令的。这时候code-gen，也就是动态PIC会在__DATA段为dylibA创建一个指针，指向dylibB的某个地址。比方说：dylibA想调用dylibB的sayHello方法，code-gen会先在Mach-O的__DATA段中建立一个指针指向sayHello，再通过这个指针实现间接调用。</p>
<h1 id="dyld-dynamic-loader-linker"><a href="#dyld-dynamic-loader-linker" class="headerlink" title="dyld (dynamic loader/linker)"></a>dyld (dynamic loader/linker)</h1><h2 id="加载dylibs"><a href="#加载dylibs" class="headerlink" title="加载dylibs"></a>加载dylibs</h2><p>dyld是iOS平台上的二进制加载器或者说动态链接器，也是内核的得力”小助手”。它负责将程序依赖的各种动态库加载到进程。同时也肩负着修复内部和外部指针指向的责任(<a href="https://opensource.apple.com/source/dyld/">传送门，dyld开源代码</a>)。下面我们就来看看dyld是如何帮助内核完成加载工作的。</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1556313280/blogImages/app_launch/dyld_vxpafe.png"></p>
<p>从上图可以看到，ALSR将dyld也加载到了进程中一个随机地址，此时的dyld和App享有同样的权限。其实从加载完dyld之后，内核要做的事情就结束了，之后的所有步骤都由dyld完成。首先，dyld会读取Mach-O文件中的指令(Load commands)，去将其依赖的各个动态库映射到当前的逻辑地址空间，如果该动态库还依赖其他动态库，比方说下图的A库依赖C库，dyld会递归的将没加载过的dylib都加载到当前进程中(<em>具体由ImageLoader完成</em>)，直到所有的动态库加载完毕。Apple官方称，一个App通常会加载1到400个dylibs! 不过幸运的是，这其中大部分是系统的dylibs，Apple在操作系统启动的时候，也已经帮我们提前计算和缓存了这些dylibs的信息，这样dyld加载它们的时候就会快很多。</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1556313614/blogImages/app_launch/dylibs_qo5got.png"></p>
<h2 id="Dirty-amp-Clean-Page"><a href="#Dirty-amp-Clean-Page" class="headerlink" title="Dirty &amp; Clean Page"></a>Dirty &amp; Clean Page</h2><p>我们在上文提到: 当<strong>Copy-On-Write</strong>发生时，该page会被标记为dirty，同时会被复制。下面我们通过一个实例来进一步理解虚拟内存和Mach-O布局，以及dyld是如何产生出dirty page的。</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1556334804/blogImages/app_launch/clean_dirty_page_gl1rhj.png"></p>
<p>上图展示的是两个不同的进程共享同一个dylib的使用场景。我们从左到右看，左边的进程1先加载了该动态库，通过读取<strong>Load Commands</strong>, dyld知道要先加载__TEXT段(可读，可执行)，上图__TEXT段大小为3个page，但是dyld只会先将第一个page映射到物理RAM。之后读取__DATA段信息(可读可写)，在Mach-O章节中，我们已经知道，__DATA段存储了全局变量，而大部分的全局变量又都被初始化为0，所以在第一次被加载的时候，虚拟内存技术会将这些全局变量直接分配到一些page上(上图是3个page)，不从磁盘中读取。接着dyld加载__LINKEDIT段，并将其映射到物理RAM2。当dyld加载__LINKEDIT(只读)段时，会被告知需要做一些”修正”以便dylib可以被顺利运行，这时，dyld就需要向__DATA段写入一些数据了。当写入发生时，该page对应的物理RAM就包含了当前进程信息，变成了dirty page。最终，这个dylib占用了8个page，包含2个clean page，一个dirty page(其余还未被映射)。</p>
<p>这时，如果有第二个进程同时引用了这个dylib，那么会发生什么呢？第一步同样是加载__TEXT段，不同的是，这次内核会发现在物理内存的某一处，已经加载过对应的__TEXT段，所以这次只是简单地把映射重定向下，不做任何IO操作。__LINKEDIT也是如此，区别就是这次变快了许多。当内核在寻找__DATA段的时候，它先会去检查是否还存在干净的副本，如果有，则直接映射；如果没有则需要重新从磁盘中读取，读取后dyld做修正，所以这个page也会变为dirty page。当dyld完成了修正过程后，__LINKEDIT也就不被再需要，内核可以在适当的时候释放其映射的物理RAM。</p>
<p>总结下: 当两个进程共享一个dylib时,使用虚拟内存技术映射物理RAM，把原本16个脏页面变成了两个脏页面和一个干净的共享页面。但上例是针对Apple自己提供的动态库，如果是我们自己写的cocoatouch framework，不排除当两个进程共用一个framework时，可以共享某些page。例如两个App都依赖Alamofire网络库时，一个App先行加载其Mach-O文件到物理内存；当另一个App加载Alamofire时，直接映射即可。</p>
<h1 id="Rebase-amp-Binding"><a href="#Rebase-amp-Binding" class="headerlink" title="Rebase &amp; Binding"></a>Rebase &amp; Binding</h1><p>这个步骤就是上文说到的”修正”步骤, 同时也用到了上文提到的PIC技术。Reabse是指修正内部指针指向; Binding是指修正外部指针指向。如下图所示: 指向_malloc和_free的指针是修正后的外部指针指向。而指向__TEXT的指针则是被修复后的内部指针指向。</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1556355653/blogImages/app_launch/rebase_binding_hyuhqt.png"></p>
<p>这个步骤发生的原因我们上文提到过: ASLR。由于起始地址的偏移，所有_DATA段内指向Mach-O文件内部的指针都需要增加这个偏移量, 并且这些指针的信息可以在__LINKEDIT段中找到。既然Rebase需要写入数据到__DATA段，那也就意味着<strong>Copy-On-Write</strong>势必会发生，dirty page的创建，IO的开销也无法避免。</p>
<p>Binding是__DATA段对外部符号的引用。不过和Rebase不同的是，binding是靠字符串的匹配来查找符号表的，虽说没有多少IO，但是计算多，比Rebase慢。</p>
<p>使用如下命令可查看所有Resabe和Binding的修复:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcrun dyldinfo -rebase -bind -lazy_bind NetworkTransport.app/NetworkTransport</span><br></pre></td></tr></table></figure>

<h1 id="Objc-Runtime"><a href="#Objc-Runtime" class="headerlink" title="Objc Runtime"></a>Objc Runtime</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Objective-C runtime是Objc这款语言的运行时函数库(<a href="https://opensource.apple.com/source/objc4/">传送门，Runtime开源代码</a>)，负责支持我们日常用到的各种动态特性，例如<strong>Target-Action，Associated Objects，Method Swizzling等。</strong>当然，功能觉不仅限于此，运行时库更像是一个桥阶层，帮助Objc和其他语言更好地协同工作。</p>
<p>Objc运行时库有很多的DATA数据结构，这些大都是系统类，这些系统类就会有很多的指针，例如指向其方法和超类。几乎所有的这些指针的修正都会在上一步完成。不过Objc runtime还需要做如下一些事情:</p>
<ol>
<li>为每一个类生成一张函数表: 在Objc里我们可以使用字符串来初始化一个类，原理就是该类拥有函数表。</li>
<li>将分类(Category)里定义的扩展添加到函数表里: 如果分类override的原类的方法，则运行时会将其添加到函数表上方，调用时先用Category中定义的方法。</li>
<li>确保选择器的唯一性: 和上一个类似，Objc是依靠Selector的，所以确保其唯一性就保证了调用的正确性。</li>
</ol>
<h2 id="Load-vs-Initialize"><a href="#Load-vs-Initialize" class="headerlink" title="Load vs Initialize"></a>Load vs Initialize</h2><p>在Objc时代，NSObject中有两个很特殊的方法: <strong>+load</strong> 和 <strong>+initialize</strong>，它们被用于类的初始化。</p>
<h3 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h3><p>当类或者是Category被添加到Objc Runtime时，+load方法即被调用。一个很典型的例子就是Method Swizzling，由于Apple “自底向上” 的初始化策略，当我们想替换系统的某个实现时，一般都会在自定义的类中重写+load方法，实现相关代码，已达到替换的目的。</p>
<div class="note info"><p><ul><li>父类+load方法 <b>先于</b> 子类+load方法执行;</li><li>主类+load方法  <b>先于</b> Category的+load方法执行;</li><li>不同类+load方法调用顺序<b>不确定</b>。</li><ul></p></div>

<p>下面我们来看看部分和+load方法相关的Objc runtime的源码，以加深对+load的理解。首先是文件<strong>objc-runtime-new.mm</strong> 中的 <strong>prepare_load_methods(header_info *hi)</strong> 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void prepare_load_methods(const headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    classref_t *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        if (!cls) continue;  // category for ignored weak-linked class</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个函数是将那些实现了+load方法的类和Category找出并实现(realized), 之后将其加入对应的loadable列表。其中<br><strong>_getObjc2NonlazyClassList</strong> 和 <strong>_getObjc2NonlazyCategoryList</strong> 两个方法就是找出这样的类和Category。Non lazy意味着它们实现了+load方法，与之对应的则是lazy class，它们没有实现+load方法，所以不会在App启动的时候初始化，而是在收到第一次消息时初始化，可谓名副其实的懒加载。Mach-O的non lazy类可以在<strong>__DATA, __objc_nlclslist</strong>部分看到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    assert(cls-&gt;isRealized());  // _read_images should realize</span><br><span class="line"></span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    // Ensure superclass-first ordering</span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>prepare_load_methods</strong>中还调用到了<strong>schedule_class_load</strong>方法，在该方法里第9行我们可以看到: 函数对传入参数的父类进行了递归调用，以确保父类优先的顺序。</p>
<p>当类和Category准备好后，Objc runtime就可以对它们的+load方法调用了。打开文件<strong>objc-loadmethod.m</strong>，找到其中的<strong>call_load_methods</strong>函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void call_load_methods(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool loading = NO;</span><br><span class="line">    bool more_categories;</span><br><span class="line">    </span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line">    </span><br><span class="line">    // Re-entrant calls do nothing; the outermost call will finish the job.</span><br><span class="line">    if (loading) return;</span><br><span class="line">    loading = YES;</span><br><span class="line">    </span><br><span class="line">    void *pool = objc_autoreleasePoolPush();</span><br><span class="line">    </span><br><span class="line">    do &#123;</span><br><span class="line">        // 1. Repeatedly call class +loads until there aren&#x27;t any more</span><br><span class="line">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 2. Call category +loads ONCE</span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line">        </span><br><span class="line">        // 3. Run more +loads if there are classes OR more untried categories</span><br><span class="line">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class="line">    </span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line">    </span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个函数有两点值得注意:</p>
<ol>
<li>第12行和第26行的<strong>auto release pool</strong>操作，这意味着我们在自定义+load方法是不需要自己添加autorelease的block，Objc runtime帮我们处理了。</li>
<li>第17行和第21行，类的+load先于Category调用。</li>
</ol>
<p>我们来看下call_class_loads的实现，call_category_loads方法和它异曲同工，就不详细介绍了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void call_class_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    </span><br><span class="line">    // Detach current loadable list.</span><br><span class="line">    struct loadable_class *classes = loadable_classes;</span><br><span class="line">    int used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = 0;</span><br><span class="line">    loadable_classes_used = 0;</span><br><span class="line">    </span><br><span class="line">    // Call all +loads for the detached list.</span><br><span class="line">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        if (!cls) continue; </span><br><span class="line">        </span><br><span class="line">        if (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Destroy the detached list.</span><br><span class="line">    if (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最关键的在第21行: (*load_method)(cls, SEL_load)。这意味着+load方法的调用不是我们熟知的 <b>objc_msgSend(消息机制)</b>，而是直接使用其内存地址的方式调用。这也意味着，父类、子类和分类中的+load方法的实现是被区别对待的。如果子类实现+load方法而父类没有实现，则父类中的+load方法不会被调用；如果主类和分类都实现了+load方法，则两个都会被调用，不过Category的+load方法会后调，这也为我们实现Swizzling提供了契机。</p>
<h3 id="initialize"><a href="#initialize" class="headerlink" title="+initialize"></a>+initialize</h3><p>+load方法在Swift中已经被废弃, 官方推荐使用+initialize来完成之前在+load中完成的事情。+initialize方法会在类或其子类收到第一条消息(方法调用)前调用。属于懒加载，节省系统资源，避免浪费。</p>
<div class="note danger"><p>Swift3.1废弃了该方法, 不过可以用Objc的Category做该Swift类的扩展，依旧可以使用该函数；纯Swift环境下也有替代方法，会在之后的文章中介绍。</p></div>

<p>打开<strong>objc-runtime-new.mm</strong>文件，找到<strong>lookUpImpOrForward</strong>方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">        // If sel == initialize, _class_initialize will send +initialize and </span><br><span class="line">        // then the messenger will send +initialize again after this </span><br><span class="line">        // procedure finishes. Of course, if this is not being called </span><br><span class="line">        // from the messenger then it won&#x27;t happen. 2778172</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当调用某个类的方法时，Objc runtime会使用这个函数去查找或者转发该消息。如果该类没有被初始化，则调用<b>_class_initialize</b>方法来初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    Class supercls;</span><br><span class="line">    bool reallyInitialize = NO;</span><br><span class="line"></span><br><span class="line">    // Make sure super is done initializing BEFORE beginning to initialize cls.</span><br><span class="line">    // See note about deadlock above.</span><br><span class="line">    supercls = cls-&gt;superclass;</span><br><span class="line">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">#if __OBJC2__</span><br><span class="line">        @try</span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">            callInitialize(cls);</span><br><span class="line"></span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第12行的递归调用保证了父类先于子类初始化；第21行调用<strong>callInitialize</strong>，代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    asm(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出+initialize方法的调用和普通函数调用一样，走的都是发送消息的流程。也就是说，无论如何，父类的+initialize都会被调用，而且如果Category实现了+initialize方法，则会”覆盖”掉主类的+initialize方法(Category的实现在函数表中优先于主类)。</p>
<p>而且还带来一个问题: 如果子类没有实现+initialize方法，那么父类的+initialize方法会被调用多次。如果想确保自己的+initialize方法只执行一次的话，有两种方式:</p>
<ol>
<li>判断当前Class是否是该类</li>
<li>使用dispatch once token(和初始化一个Singleton一样)</li>
</ol>
<p>BTW, 无论是+load还是+initialize，都不需要在自己的实现里调用super load或者是super initialize。</p>
<h1 id="Main函数的调用"><a href="#Main函数的调用" class="headerlink" title="Main函数的调用"></a>Main函数的调用</h1><p>dyld调用UIApplicationMain()。</p>
<p>总结下: 内核加载App和dyld到进程中，dyld加载所有依赖的dylibs，修正所有DATA page，之后Objc runtime初始化所有类，最后调用main函数。</p>
<h1 id="如何优化App启动时间"><a href="#如何优化App启动时间" class="headerlink" title="如何优化App启动时间"></a>如何优化App启动时间</h1><p>熬过了理论部分，现在我们来看看如何将其应用到实际开发中，来提升我们App的启动速度。</p>
<h2 id="Apple已有的优化"><a href="#Apple已有的优化" class="headerlink" title="Apple已有的优化"></a>Apple已有的优化</h2><p>Apple的dyld 3(目前使用版本)与之前的dyld 2相比有了显著的优化。dyld 3由三个部分构成: </p>
<ul>
<li>进程无关的Mach-O解析器</li>
<li>进程相关的启动回调引擎</li>
<li>启动回调缓存服务</li>
</ul>
<p>启动回调(Launch Closure)是dyld 3引进的一个新概念，它是指启动你App所有的必要信息。比方说: 你的App用到哪些动态库，指针偏移量，代码签名位置等等。</p>
<p>在dyld 2时代，所有我们之前提到的启动步骤都是发生在内核分配给你的进程中的(in-process); 而在dyld 3中，关于Mach-O文件的解析发生在App第一次安装或者是之后的更新过程中。解析过后，关于App启动的信息会被存到磁盘的某处，供App启动时使用。这两步大大提升了App加载的速度，系统库是有共享缓存的，所以加载速度不会慢，但我们自己App中也会有很多依赖库，每次根据@rpath查找，映射也是很耗时的工作，而且从App下载之后，这些依赖库也不会再变了，把它们放到out of process中实为明智之举。</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1556520588/blogImages/app_launch/dyld3_zfbbh0.png"></p>
<p>上图中虚线以上部分就是App第一次下载或更新时dyld会做的事情。虚线以下就是当App加载到进程中后dyld会做的事情, 除了需要从缓存中读取和验证信息之外，其他步骤都是一样的。</p>
<p>Apple为什么要这样做？除了我们已经提到的性能优化，还有两个主要原因: 安全和可靠性。先说可靠性: 将这些步骤移出进程意味着dyld的大部分工作就像是一个普通的守护程序，Apple的工程师可以用标准工具去测试它，提升可靠性；至于安全性，Apple认为最容易被攻击的步骤是解析Mach-O头部和查询依赖库。攻击者可以搞乱App的@rpath路径，或者替换为其它library来完成<br>@rpath confusion attacks</br>. 所以Apple将其放入守护进程中加载。除此之外，符号表查找是另一项耗时工作，也完全可以放在进程外执行。因为除非更新软件和修改依赖库，否则该依赖库的符号表的内部偏移量是不会变的。</p>
<h2 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h2><p>在优化之前，我们需要知道如何测量启动时间，为什么启动时间会慢以及多长时间的启动时间是可被接受的。</p>
<h3 id="推荐的启动时间"><a href="#推荐的启动时间" class="headerlink" title="推荐的启动时间"></a>推荐的启动时间</h3><p>Apple推荐的启动时间是400ms, 当然最好是在App支持的最低配设备上达到这个标准。最长不要超过20s，否则系统会直接kill掉这个App。</p>
<h3 id="如何测量启动时间"><a href="#如何测量启动时间" class="headerlink" title="如何测量启动时间"></a>如何测量启动时间</h3><p>Apple提供一个内置的环境变量来记录App启动时间(pre-main): <strong>DYLD_PRINT_STATISTICS</strong>。 具体配置方法如下:</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1556590441/blogImages/app_launch/statistics_x6tbzk.png"></p>
<p>之后启动App，在console中就可看到如下信息:</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1556579291/blogImages/app_launch/pre-main_dzlj6z.png"></p>
<p>值得一提的是: dyld很智能，它会自动扣除Debugger的插入时间，所以不用担心Dev版本时间与发布版本不同。</p>
<h3 id="优化启动时间"><a href="#优化启动时间" class="headerlink" title="优化启动时间"></a>优化启动时间</h3><p>基于上文的console信息，我们的优化可以从4个方面来开始:</p>
<p>第一: 减少动态库的依赖。在iOS平台下，尽量减少项目所依赖的动态库; 如果无法减少，尝试将不同动态库合并。在项目开发阶段，有些程序员偏爱创建CocoaTouch Framework，觉得分离出业务逻辑以及依赖资源对开发和以后维护都有好处。但是，当这样做的时候，也需要考虑下App的启动时间以及性能，是否值得这样做。Apple的WWDC2016(Session 406)给出了一个例子: 一个项目依赖26个动态库，dylibs加载时间是240毫秒; 当将其合并成2个动态库时，加载时间变为20毫秒，可以说性能显著提高。</p>
<p>第二: 减少指针的使用。从上图中我们可以发现, rebase和binding的时间占据了最多的时间消耗。也就是说dyld修复指针指向花费了300多毫秒。从上文我们知道，dyld修复的指针都位于__DATA段，所以我们需要做的很简单，减少项目中指针的使用。如何减少? 如果你的项目使用纯Objc开发，那就要适当减少类的个数，根据WWDC2016(Session 406)，Apple工程师的说法，项目中包含100，1000个类没什么太大的overhead，但要是5000到20000以上，则加载时间会多700到800毫秒。如果工程使用Swift居多，甚至是纯Swift，那么Apple建议能使用struct则使用struct，因为struct是值类型，不会引入指针(使用偏移量)。</p>
<p>第三: 优化Objc建立时间。这一步包含四个步骤: </p>
<ol>
<li>注册类</li>
<li>更新类实例变量偏移(例如SDK更新)</li>
<li>注册Category</li>
<li>选择器的唯一性</li>
</ol>
<p>这一步其实不用我们来优化，因为大部分的工作Apple已经帮我们做了，比方说ivar的偏移，这些会在rebase &amp; binding步骤完成。</p>
<p>第四: 初始化。在iOS平台下，如果项目使用Objc编写，尽量少使用+load方法，如果非要使用, 替换为+initialize，延迟加载。如果项目已经使用Swift编写，那就没什么优化的了，Apple暗地里帮我们调用了他们自己的initializer(dispatch_once), 确保Swift class不会被初始化多次。</p>
<p>不过Apple给的启动时间的信息还是太少，除了前三步，最后一步其实是可以度量的。现在的iOS App很多都在使用Cocoapods或是Carthage加载第三方依赖库。如果我们想获得每一个这样的依赖库初始化耗时时间，该怎么做呢？简单说就是Swizzling <strong>+load</strong>方法加上Instrument Static Initializers工具来追踪时间消耗，具体步骤可以参考这篇文章: <a href="https://juejin.im/post/59c623aff265da065754dc07">如何精确度量 iOS App 的启动时间.</a></p>
<p>这篇文章大致介绍了下App启动的流程, 涵盖的知识点比较多，无法在有限的篇幅里面再扩展更多。今后的文章里会有针对某一个知识点的深入挖掘，敬请期待!</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/">Objective-C +load vs +initialize</a><br><a href="https://wangdetong.github.io/2017/09/11/20170911%E4%BB%8E-dyld-%E5%88%B0-runtime/">从 dyld 到 runtime</a><br><a href="https://developer.apple.com/videos/play/wwdc2017/413/">App Startup Time: Past, Present, and Future</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/406/?time=1154">Optimizing App Startup Time</a><br><a href="https://juejin.im/post/59c623aff265da065754dc07">如何精确度量 iOS App 的启动时间</a></p>
]]></content>
      <categories>
        <category>开发基础</category>
        <category>优化</category>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>dyld</tag>
        <tag>Mach-O</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift Concurrency 初探</title>
    <url>/2021/11/21/Swift-Concurrency-%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h1><p>协程, 又名纤程，是一种协作式的任务调度模式，程序可以主动挂起或者恢复执行。简单来说就是我们自己可以控制程序/函数的挂起和恢复，而不阻塞当前的执行线程。从这里大家可以看出，协程是一种比线程还轻量级的调度单元，无需类似进程，线程的上下文切换，不消耗CPU资源。</p>
<div class="note warning"><p>线程是操作系统层面的概念，协程是语言层面的概念。</p></div>

<p>下面我们通过 <strong>生产者-消费者模型</strong> 来看看到底什么是协程:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>():</span></span><br><span class="line">    r = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n: <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[CONSUMER] Consuming %s...&#x27;</span> % n)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        r = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span>(<span class="params">c</span>):</span></span><br><span class="line">    c.__next__()</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Producing %s...&#x27;</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Consumer return: %s&#x27;</span> % r)</span><br><span class="line">        </span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">        c = consumer()</span><br><span class="line">        produce(c)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>这里使用Python3的<strong>yield</strong>生成器实现了一个简单的生产-消费模型，简单来说就是生产一个，消费一个，直到循环结束。输出结果如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[PRODUCER] Producing <span class="number">1.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">1.</span>..</span><br><span class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</span><br><span class="line">[PRODUCER] Producing <span class="number">2.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">2.</span>..</span><br><span class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</span><br><span class="line">[PRODUCER] Producing <span class="number">3.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">3.</span>..</span><br><span class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</span><br><span class="line">[PRODUCER] Producing <span class="number">4.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">4.</span>..</span><br><span class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</span><br><span class="line">[PRODUCER] Producing <span class="number">5.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">5.</span>..</span><br></pre></td></tr></table></figure>
<p>可以看到，整个流程没有创建任何线程锁，由一个线程执行，producer和consumer协作式完成任务。这种方式不会使得线程被block，可以被系统重新分配。例如我们使用协程调度进行I/O操作，那么I/O操作便不会阻塞当前线程，使得系统可以重新分配当前线程给其他任务。</p>
<h1 id="Swift协程"><a href="#Swift协程" class="headerlink" title="Swift协程"></a>Swift协程</h1><p>Swift协程，也就是Swift Concurrency，是Apple在 Swift 5.5 新引入的并发机制，填补了其在协程领域的空白。总的来说，Swift Concurrency包含四个部分： <strong>async-let tasks, group task,  unstructured tasks 和detached tasks</strong>.</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Launched by</th>
<th align="center">Launchable from</th>
<th align="center">Lifetime</th>
<th align="center">Cancellation</th>
<th align="center">Inherits from origin</th>
</tr>
</thead>
<tbody><tr>
<td align="center">async-let tasks</td>
<td align="center">async let x</td>
<td align="center">async functions</td>
<td align="center">scoped to statement</td>
<td align="center">automatic</td>
<td align="center">priority, task-local values</td>
</tr>
<tr>
<td align="center">Group tasks</td>
<td align="center">group.async</td>
<td align="center">withTaskGroup</td>
<td align="center">scoped to task group</td>
<td align="center">automatic</td>
<td align="center">priority, task-local values</td>
</tr>
<tr>
<td align="center">Unstructured tasks</td>
<td align="center">Task</td>
<td align="center">anywhere</td>
<td align="center">unscoped</td>
<td align="center">via Task</td>
<td align="center">priority, task-local values, actor</td>
</tr>
<tr>
<td align="center">Detached tasks</td>
<td align="center">Task.detached</td>
<td align="center">anywhere</td>
<td align="center">unscoped</td>
<td align="center">via Task</td>
<td align="center">nothing</td>
</tr>
</tbody></table>
<h2 id="协程使用"><a href="#协程使用" class="headerlink" title="协程使用"></a>协程使用</h2><h3 id="Conurrent-Bindings"><a href="#Conurrent-Bindings" class="headerlink" title="Conurrent Bindings"></a>Conurrent Bindings</h3><p>第一种使用方法是<strong>async let</strong>， 例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">let</span> result1 <span class="operator">=</span> <span class="type">URLSession</span>.shared.data(<span class="operator">...</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">let</span> result2<span class="operator">=</span> <span class="type">URLSession</span>.shared.data(<span class="operator">...</span>)</span><br><span class="line"><span class="keyword">try</span> <span class="keyword">await</span> result1</span><br><span class="line"><span class="keyword">try</span> <span class="keyword">await</span> result2</span><br></pre></td></tr></table></figure>
<p>这种方法适用于有顺序依赖关系，而且个数一定的场景。例如上传图片，一般来说上传分两步，第一步上传图片本身资源；第二部上传图片url。这样就可以利用Conurrent Bindings方式按步骤完成任务。</p>
<p>这里要引入<strong>Task Tree</strong>的概念。简单来说，以上我们提到的四种创建协程的方式都是基于Task来完成的，只不过前两个树状结构的tasks，后两个是无结构的tasks。那什么是树状结构Task呢？</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1637870368/blogImages/Swift_Concurrency/task_tree_h8lxes.png"></p>
<p>上图是Apple WWDC 2021 <strong>Explore structured concurrency in Swift</strong> 的截图，从图中可以很直观的看出task之间的关系: fetchOne作为parent task，旗下有两个sub task, 一个是获取image metadata，另一个是获取image data。使用这种结构的好处就是：我们不必关心task的生命周期, 系统会根据task tree的完成情况，根据结构自动退出，进而按需抛出异常。</p>
<div class="note info"><p>取消task并不意味着task的执行立即结束，系统会标记该task的结果不再需要了；也意味着我们还需要手动检查task是否取消。</p></div>

<h3 id="Group-Task"><a href="#Group-Task" class="headerlink" title="Group Task"></a>Group Task</h3><p>Group task是Swift协程的另外一种结构化方式，和async let的显著区别就是可以 “多并发” 的发起多个任务，然后再通过group将结果 “join”起来。</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1638211420/blogImages/Swift_Concurrency/group_task_hawdag.png"></p>
<p>parent task和sub tasks的关系和variable binding的相同。这里唯一要注意的就是 <strong>group.async</strong> (已过期，需要使用addTask) 是一个<strong>sendable</strong>修饰的closure，这种closure是无法capture普通mutable variables，只能capture可以安全访问的变量，例如actor修饰的type，实现了同步机制的class，或者是直接返回value type。</p>
<h3 id="Unstructured-tasks"><a href="#Unstructured-tasks" class="headerlink" title="Unstructured  tasks"></a>Unstructured  tasks</h3><p>Swift协程也支持非结构化的Task。 例如在UI线程调用Task以及调用超出当前scope的Task。<strong>Explore structured concurrency in Swift</strong> 提到了两种非结构Task, 都很好理解： 第一种如下图，是在显示cell的时候，调用<strong>fetch</strong>函数, 创建Task: </p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1643425974/blogImages/Swift_Concurrency/unstru_1_l88yhq.png"></p>
<p>之后在endDisplay的时候取消Task(一行代码，就不贴了)。这里的Task会继承主线程的context，原因是Task使用了主线程上下文环境的变量，也就意味着fetch本身会发生在main thread。如果不使用主线程上下文变量，则系统会分配其他线程执行Task。</p>
<p>第二种是<strong>Detached Task</strong>，他的生命周期和调用它的scope并无绑定关系，可以执行一些低优先级任务，例如下图：</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1643436531/blogImages/Swift_Concurrency/detached_kvrik9.png"></p>
<p>这种Task按理说也是要我们手动去cancel的，不过例如本地缓存这样的功能，个人感觉不是必须要支持cancel；不过在使用非结构化的Task时，要记住考虑Task取消的情况，这属于一个best practice。</p>
<h1 id="Swift-Concurrency原理窥探"><a href="#Swift-Concurrency原理窥探" class="headerlink" title="Swift Concurrency原理窥探"></a>Swift Concurrency原理窥探</h1><p>了解了四种Task的使用方式后，不知道你们有没有和我一样的疑问❓那就是<strong>async/await</strong>这种机制是如何实现线程挂起和恢复的？详细点说就是：当async函数执行完毕后，如何回到之前的位置，继续执行其后的方法？</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1643510467/blogImages/Swift_Concurrency/swiftui_ztjvfr.png"></p>
<p>上图是一个简单的异步样例：在view渲染完毕后，触发一个异步函数，获取结果然后刷新页面。<strong>testAsync</strong>函数会跑在一个工作线程上，但await之后的内容是跑在主线程上的。这就保证了我们能以一种看似同步的方式写异步代码。</p>
<p>但这又是怎么实现的呢？Apple没有开源Swift Concurrency的代码，所以我们无法直接获取它的实现方式；不过好在Kotlin是开源的，而且也支持协程，我们可以参考kotlin的实现方式，来推测下Swift Concurrency的实现。</p>
<p>总的来讲，Kotlin协程的实现方式是：使用匿名状态机，调度器(Dispatcher)和Continuation实现协程的挂起和恢复。</p>
<p>我们来看一个简单的例子:</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1643525935/blogImages/Swift_Concurrency/kotlin_co_u2qc5a.png"></p>
<p><strong>test</strong>函数启动了一个协程，运行该协程的线程可以是线程池中任意一个线程。在协程体中，test0和test2都是普通函数，也就意味着执行他们的线程是一样的；<strong>test1</strong>则不同，该函数是一个可挂起函数，和Swift的async函数类似，不同之处在于该函数有指定的调度器: Dispachers.IO，意味着该函数也不会在主线程运行。那在test1执行完毕后，系统是如何切回一开始分配的线程池中的线程呢？</p>
<p>让我们来看下反编译这段代码的结果:</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1643536215/blogImages/Swift_Concurrency/decompile_ezqxz0.png"></p>
<p>我截取了部分代码(有代码重复), 可以看到<strong>invokeSuspend</strong>中有switch，将函数分为了两个状态: label 0 和 label 1, 当label为一，也就是运行函数test1时，<strong>invokeSuspend</strong>返回一个挂起函数；当test1结束运行时，最外层的<strong>continuation</strong>会调用<strong>resume</strong>方法，并且其中的调度器会决定切回到哪个线程，最终跳出switch，执行test2和test0。这里的continuation其实是kotlin对协程体的封装。</p>
<p>上面的switch其实可以看做是一个状态机，配合continuation和线程调度器，最终实现了函数的挂起和恢复，以及线程切换。完全的代码控制，不涉及传统的线程上下文切换，从而降低系统资源消耗。</p>
<p>Swift Concurrency实现原理个人认为是类似的，我们来看一个例子:</p>
<p><img src="https://res.cloudinary.com/dwpjzbyux/image/upload/v1643537110/blogImages/Swift_Concurrency/sc_ym55jq.png"></p>
<p>这个是Swift中Continuation的用法，主要是作为一个新旧代码的桥梁来使用。乍一看和kotlin的Continuation是两回事，但仔细思考下：<strong>withCheckedThrowingContinuation</strong>也是要suspend当前Task，最后resume；也就是说这个Continuation中，很可能也持有和Kotlin类似的线程调度器，不过在Swift中应该叫做<strong>executor</strong>，例如MainActor。</p>
<p>以上是Swift Concurrency大致原理。了解了原理后，我们才能写出准确，强壮的代码，避免性能问题，充分发挥协程优势。</p>
]]></content>
      <categories>
        <category>Swift 语言特性</category>
        <category>并发</category>
        <category>协程</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
        <tag>Coroutine</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
</search>
